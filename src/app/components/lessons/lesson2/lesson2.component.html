<!-- [ngStyle] showcase1:  change background color based on method -->
<h2>Lession 2: Directives</h2>
<h4>[ngStyle]</h4>
Write 'green' to see the change.
<input type="text" class="form-control" (input)="updateColor($event)" />

<p [ngStyle]="{ backgroundColor: getColor() }">{{ color }}</p>

<!-- [ngStyle] showcase2: toggle the "special" class on/off with a property -->
<h4>ngClass</h4>
<div [ngClass]="isSpecial ? 'special' : ''">I'm a div</div>
<button (click)="changeClass()">Change Class</button>


<!-- *ngIf showcase: add or remove element -->
<h4>*ngIf</h4>
<p
  [ngStyle]="{ width: '100px', backgroundColor: 'red', margin: 'auto' }"
  *ngIf="condition === true"
>
  I'm a paragraph
</p>
<button (click)="changeCondition()">Remove paragraph!</button>


<!-- *ngFor showcase: dynamically display elements of array -->
<h4>*ngFor</h4>
<form (ngSubmit)="onSubmit()" #formName="ngForm">
  <input [(ngModel)]="hero" name="name" id="name" #name="ngModel" required />
  <button type="submit" [disabled]="!formName.form.valid">Add Hero</button>
</form>

<table class="table">
  <thead>
    <th>ID</th>
    <th>Name</th>
  </thead>
  <tbody>
    <tr *ngFor="let hero of heroes; let i = index">
      <td>{{ i + 1 }}</td>
      <td>{{ hero }}</td>
    </tr>
  </tbody>
</table>

<!-- [ngSwitch] showcase -->
<h4>[ngSwitch]</h4>

<div class='switchDiv'>
  Input string (try numbers 1-5): <input type="text" [(ngModel)]="num" />

  <div [ngSwitch]="num">
    <div *ngSwitchCase="'1'">One</div>
    <div *ngSwitchCase="'2'">Two</div>
    <div *ngSwitchCase="'3'">Three</div>
    <div *ngSwitchCase="'4'">Four</div>
    <div *ngSwitchCase="'5'">Five</div>
    <div *ngSwitchDefault>This is Default</div>
  </div>
</div>

<!-- Renderer showcase / custom directives (example.directive.ts)-->

<h4>Custom directives and Renderer2</h4>
The Renderer2 class is an abstraction provided by Angular in the form of a
service that allows to manipulate elements of your app without having to touch
the DOM directly. This is the recommended approach because it then makes it
easier to develop apps that can be rendered in environments that don’t have DOM
access, like on the server, in a web worker or on native mobile. You’ll often
use Renderer2 in custom directives because of how Angular directives are the
logical building block for modifying elements.

<br />
<br />

<div appExample class="myDiv">
  I'm a div and my color is changed by a custom directive!
</div>

<h4>@HostListener</h4>
@HostListener is a function decorator that declares a DOM event to listen for,
and provides a handler method to run when that event occurs.

<button appExample>Check the console for click count</button>

<br />
<br />

<!--@hostlistener example 2-->

<div appExample2>
  Hover me!
  <p style="display: none" class="secretParagraph">
    <img src="assets/img/yoda.png" style="width: 60px" />
    {{ punchline }}
  </p>
</div>

<h4>@HostBinding</h4>
*a better approach than using Renderer2 (does the same, but the code is
cleaner)* @HostBinding binds the property to the host element. If a binding
changes, @HostBinding will update the host element.
<div appExample3>I got my color from a directive!</div>
